package bootstrap

import (
	"context"
	"github.com/integration-system/golang-socketio"
	"os"
	"reflect"
	"time"

	"encoding/json"
	"strings"

	"github.com/mohae/deepcopy"
	"github.com/thecodeteam/goodbye"
	"github.com/integration-system/isp-lib/backend"
	"github.com/integration-system/isp-lib/config"
	"github.com/integration-system/isp-lib/config/schema"
	"github.com/integration-system/isp-lib/logger"
	"github.com/integration-system/isp-lib/socket"
	"github.com/integration-system/isp-lib/structure"
	"github.com/integration-system/isp-lib/utils"
)

const LibraryVersion = "0.3.7"

type SocketConfigProducer func(localConfigPtr interface{}) socket.SocketConfiguration

type ShutdownHandler func(ctx context.Context, sig os.Signal)

type SocketConsumer func(sockClient *gosocketio.Client)

type routesDataProducer func(localConfigPtr interface{}) SendRoutesData

type SendRoutesData struct {
	ModuleName       string
	MethodPrefix     string
	Version          string
	AwaitEvents      []string
	GrpcOuterAddress structure.AddressConfiguration
	Handlers         []interface{}
}

type remoteConf struct {
	Config interface{}
	Client *gosocketio.Client
}

type serviceBootstrap struct {
	localConfigPtr  interface{}
	remoteConfigPtr interface{}

	remoteConfigChan chan remoteConf

	localConfigType  string
	remoteConfigType string

	sockCfgProducer SocketConfigProducer
	sockConsumer    SocketConsumer

	onLocalConfigLoad          *reflect.Value
	onRemoteConfigReceive      *reflect.Value
	onSocketErrorReceive       *reflect.Value
	onConfigErrorReceive       *reflect.Value
	onConverterAnnounceReceive *reflect.Value
	onRouterAnnounceReceive    *reflect.Value
	onLocalConfigChange        interface{}

	onShutdown ShutdownHandler

	sendRemoteConfigSchema bool
	version                string
	libVersion             string

	listenConverterAnnounce bool

	routesDataProducer
}

/**
 * Add an event listener for the moment when the local config for an application loaded
 */
func (sb *serviceBootstrap) OnLocalConfigLoad(f interface{}) *serviceBootstrap {
	rv, rt := reflect.ValueOf(f), reflect.TypeOf(f)
	assertSingleParamFunc(rt, sb.localConfigType)
	sb.onLocalConfigLoad = &rv
	return sb
}

/**
 * Add an event listener for the moment when the local config for current application changed
 */
func (sb *serviceBootstrap) OnLocalConfigChange(f interface{}) *serviceBootstrap {
	rt := reflect.TypeOf(f)
	assertTwoParamFunc(rt, sb.localConfigType)
	sb.onLocalConfigChange = f
	return sb
}

/**
 * Add an event listener for the moment when the error message receive
 */
func (sb *serviceBootstrap) OnSocketErrorReceive(f interface{}) *serviceBootstrap {
	rv, rt := reflect.ValueOf(f), reflect.TypeOf(f)
	assertSingleParamFunc(rt, reflect.TypeOf(map[string]interface{}{}).String())
	sb.onSocketErrorReceive = &rv
	return sb
}

/**
 * Add an event listener for the moment when the config error message receive
 */
func (sb *serviceBootstrap) OnConfigErrorReceive(f interface{}) *serviceBootstrap {
	rv, rt := reflect.ValueOf(f), reflect.TypeOf(f)
	assertSingleParamFunc(rt, "string")
	sb.onConfigErrorReceive = &rv
	return sb
}

/**
 * Add an event listener for the moment when the converters address list received
 */
func (sb *serviceBootstrap) OnConverterAnnounceReceive(f interface{}) *serviceBootstrap {
	rv, rt := reflect.ValueOf(f), reflect.TypeOf(f)
	assertSingleParamFunc(rt, reflect.TypeOf([]structure.AddressConfiguration{}).String())
	sb.onConverterAnnounceReceive = &rv
	return sb
}

/**
 * Add an event listener for the moment when the routers address list received
 */
func (sb *serviceBootstrap) OnRouterAnnounceReceive(f interface{}) *serviceBootstrap {
	rv, rt := reflect.ValueOf(f), reflect.TypeOf(f)
	assertSingleParamFunc(rt, reflect.TypeOf([]structure.AddressConfiguration{}).String())
	sb.onRouterAnnounceReceive = &rv
	return sb
}

/**
 * If set true, will call backend.SetConvertersAddrList when new converter address received
 */
func (sb *serviceBootstrap) ListenConverterAnnounce(listen bool) *serviceBootstrap {
	sb.listenConverterAnnounce = listen
	return sb
}

/**
 * Add an event listener for the moment when an application received its configuration
 */
func (sb *serviceBootstrap) OnRemoteConfigReceive(f interface{}) *serviceBootstrap {
	if sb.remoteConfigType == "" {
		logger.Fatal("Remote config type is undefined.")
		return nil
	}
	rv, rt := reflect.ValueOf(f), reflect.TypeOf(f)
	assertTwoParamFunc(rt, sb.remoteConfigType)
	sb.onRemoteConfigReceive = &rv
	return sb
}

/**
 * Add a hook for executing a code when an application is ready to be ended
 */
func (sb *serviceBootstrap) OnShutdown(f ShutdownHandler) *serviceBootstrap {
	sb.onShutdown = f
	return sb
}

/**
 * Specify the socket builder function that creates a socket configuration
 */
func (sb *serviceBootstrap) SocketConfiguration(f SocketConfigProducer) *serviceBootstrap {
	sb.sockCfgProducer = f
	return sb
}

/**
 * Add an event listener for the moment when an application is established a connection to an config-service
 */
func (sb *serviceBootstrap) AfterSocketInit(f SocketConsumer) *serviceBootstrap {
	sb.sockConsumer = f
	return sb
}

func (sb *serviceBootstrap) SendRemoteConfigSchemaWithVersion(version string) *serviceBootstrap {
	if sb.remoteConfigType == "" {
		logger.Fatal("Remote config type is undefined.")
		return nil
	}
	if strings.TrimSpace(version) == "" {
		logger.Fatal("Version is undefined")
		return nil
	}
	sb.sendRemoteConfigSchema = true
	sb.version = version
	return sb
}

/**
 * Specify the routes builder function that creates a list of routes that will be announced as api methods
 */
func (sb *serviceBootstrap) SendRoutes(f routesDataProducer) *serviceBootstrap {
	sb.routesDataProducer = f
	return sb
}

/**
 * Run the application
 */
func (sb *serviceBootstrap) Run() {
	if sb.sockCfgProducer == nil {
		logger.Fatal("Socket configuration is not specified. Call 'SocketConfiguration' first")
		return
	}

	if sb.onLocalConfigChange != nil {
		config.OnConfigChange(sb.onLocalConfigChange)
	}
	sb.localConfigPtr = config.InitConfigV2(sb.localConfigPtr, false)
	if sb.onLocalConfigLoad != nil {
		sb.callOnConfigLoad()
	}

	sockConfig := sb.sockCfgProducer(sb.localConfigPtr)
	sockClient := socket.InitClient(sockConfig, func(client *gosocketio.Client) {
		if sb.onSocketErrorReceive != nil {
			sb.subscribeToErrorReceive(client)
		}
		if sb.onConfigErrorReceive != nil {
			sb.subscribeToConfigErrorReceive(client)
		}
		if sb.remoteConfigPtr != nil {
			sb.subscribeToReceiveRemoteConfig(client, utils.SendConfigWhenConnected)
			sb.subscribeToReceiveRemoteConfig(client, utils.SendConfigChanged)
			sb.subscribeToReceiveRemoteConfig(client, utils.SendConfigOnRequest)
		}
		if sb.listenConverterAnnounce || sb.onConverterAnnounceReceive != nil {
			sb.subscribeToReceiveConverterAnnounce(client)
		}
		if sb.onRouterAnnounceReceive != nil {
			sb.subscribeToReceiveRouterAnnounce(client)
		}
		if sb.sockConsumer != nil {
			sb.sockConsumer(client)
		}
	})
	if sb.sendRemoteConfigSchema {
		sb.sendSchema(sockClient)
	}
	if sb.remoteConfigPtr != nil {
		sb.remoteConfigChan = make(chan remoteConf)
		sb.awaitRemoteConfig()
	}

	exit := make(chan struct{})
	ctx := context.Background()
	defer goodbye.Exit(ctx, 0)
	goodbye.Notify(ctx)
	goodbye.Register(func(ctx context.Context, sig os.Signal) {
		logger.Info(logger.FmtAlertMsg("module shutting down now"))

		socket.GetClient().Close()
		if sb.onShutdown != nil {
			sb.onShutdown(ctx, sig)
		}

		logger.Info(logger.FmtAlertMsg("module has gracefully shut down"))

		exit <- struct{}{}
	})

	<-exit
}

func (sb *serviceBootstrap) callOnConfigLoad() {
	sb.onLocalConfigLoad.Call([]reflect.Value{reflect.ValueOf(sb.localConfigPtr)})
}

func (sb *serviceBootstrap) callOnRemoteConfigReceive(newRemoteConfig, oldRemoteConfig interface{},
	client *gosocketio.Client) {

	oldCfg := reflect.ValueOf(oldRemoteConfig)
	newCfg := reflect.ValueOf(newRemoteConfig)
	sb.onRemoteConfigReceive.Call([]reflect.Value{newCfg, oldCfg})
	if sb.routesDataProducer != nil {
		sb.sendRoutes(client)
	}
}

func (sb *serviceBootstrap) subscribeToReceiveRemoteConfig(sockClient *gosocketio.Client, eventName string) {
	sockClient.On(eventName, func(c *gosocketio.Channel, args string) error {
		logger.Infof("--- Got event: %s message: %s", eventName, args)

		oldConfig := deepcopy.Copy(sb.remoteConfigPtr)
		newRemoteConfig := config.InitRemoteConfig(oldConfig, args)
		sb.remoteConfigChan <- remoteConf{Client: sockClient, Config: newRemoteConfig}
		return nil
	})
}

func (sb *serviceBootstrap) subscribeToErrorReceive(sockClient *gosocketio.Client) {
	sockClient.On(utils.ErrorConnection, func(c *gosocketio.Channel, args map[string]interface{}) error {
		logger.Infof("--- Got event: %s message: %s", utils.ErrorConnection, args)

		sb.onSocketErrorReceive.Call([]reflect.Value{reflect.ValueOf(args)})
		return nil
	})
}

func (sb *serviceBootstrap) subscribeToConfigErrorReceive(sockClient *gosocketio.Client) {
	sockClient.On(utils.ConfigError, func(c *gosocketio.Channel, args string) error {
		logger.Infof("--- Got event: %s message: %s", utils.ConfigError, args)

		sb.onConfigErrorReceive.Call([]reflect.Value{reflect.ValueOf(args)})
		return nil
	})
}

func (sb *serviceBootstrap) subscribeToReceiveConverterAnnounce(sockClient *gosocketio.Client) {
	sockClient.On(utils.SendNewConverterConnected, func(c *gosocketio.Channel, args string) error {
		logger.Debugf("--- Got event: %s message: %v", utils.SendNewConverterConnected, args)

		list := make([]structure.AddressConfiguration, 0)
		if err := json.Unmarshal([]byte(args), &list); err != nil {
			logger.Error(err)
			return err
		} else {
			if sb.listenConverterAnnounce {
				backend.SetConvertersAddrList(list)
			}
			if sb.onConverterAnnounceReceive != nil {
				sb.onConverterAnnounceReceive.Call([]reflect.Value{reflect.ValueOf(list)})
			}
		}
		return nil
	})
}

func (sb *serviceBootstrap) subscribeToReceiveRouterAnnounce(sockClient *gosocketio.Client) {
	sockClient.On(utils.SendNewRouterConnected, func(c *gosocketio.Channel, args string) error {
		logger.Debugf("--- Got event: %s message: %v", utils.SendNewRouterConnected, args)

		list := make([]structure.AddressConfiguration, 0)
		if err := json.Unmarshal([]byte(args), &list); err != nil {
			logger.Error(err)
			return err
		} else {
			if sb.onRouterAnnounceReceive != nil {
				sb.onRouterAnnounceReceive.Call([]reflect.Value{reflect.ValueOf(list)})
			}
		}
		return nil
	})
}

func (sb *serviceBootstrap) awaitRemoteConfig() {
	go func() {
		init := false
		for {
			if !init {
				select {
				case <-time.After(3 * time.Second):
					logger.Warn("Remote config isn't received")
				case newRemoteConfig := <-sb.remoteConfigChan:
					old := sb.remoteConfigPtr
					if sb.onRemoteConfigReceive != nil {
						sb.callOnRemoteConfigReceive(newRemoteConfig.Config, old, newRemoteConfig.Client)
					}
					sb.remoteConfigPtr = newRemoteConfig.Config
					init = true
				}
			} else {
				newRemoteConfig := <-sb.remoteConfigChan
				old := sb.remoteConfigPtr
				if sb.onRemoteConfigReceive != nil {
					sb.callOnRemoteConfigReceive(newRemoteConfig.Config, old, newRemoteConfig.Client)
				}
				sb.remoteConfigPtr = newRemoteConfig.Config
			}
		}
	}()
}

func (sb *serviceBootstrap) sendSchema(sockClient *gosocketio.Client) {
	s := schema.GenerateConfigSchema(sb.remoteConfigPtr)
	req := schema.ConfigSchema{Version: sb.version, Schema: s}
	if bytes, err := json.Marshal(req); err != nil {
		logger.Error("Could not serialize config schema to JSON", err)
	} else if err := sockClient.Emit(utils.SendConfigSchema, string(bytes)); err != nil {
		logger.Error("Could not send config schema", err)
	}
}

func (sb *serviceBootstrap) sendRoutes(sockClient *gosocketio.Client) {
	data := sb.routesDataProducer(config.Get())
	prefix := data.MethodPrefix
	if prefix == "" {
		prefix = data.ModuleName
	}
	methods := backend.CreateBackendConfig(
		structure.ModuleInfo{ModuleName: data.ModuleName, Version: data.Version, LibVersion: sb.libVersion, AwaitEvents: data.AwaitEvents},
		data.GrpcOuterAddress,
		prefix,
		data.Handlers...,
	)
	logger.Debugf("EXPORTED MODULE METHODS: %v", methods)
	logger.Infof("EXPORTED MODULE METHODS: %d", len(methods.Endpoints))
	if s, err := json.Marshal(methods); err != nil {
		logger.Warn("Could not serialize methods list to JSON", err)
	} else if err := sockClient.Emit(utils.SendRoutesWhenConnected, string(s)); err != nil {
		logger.Warn("Could not send methods list", err)
	}
}

/**
 * The main method and the entry point to create Service Bootstrap instance
 */
func ServiceBootstrap(localConfigPtr, remoteConfigPtr interface{}) *serviceBootstrap {
	if localConfigPtr == nil || reflect.TypeOf(localConfigPtr).Kind() != reflect.Ptr {
		logger.Fatal("Expecting not nil pointer to local config struct")
		return nil
	}
	if remoteConfigPtr != nil && reflect.TypeOf(remoteConfigPtr).Kind() != reflect.Ptr {
		logger.Fatal("Expecting not nil pointer to remote config struct")
		return nil
	}
	sb := &serviceBootstrap{
		localConfigPtr:  localConfigPtr,
		localConfigType: reflect.TypeOf(localConfigPtr).String(),
		libVersion:      LibraryVersion,
	}
	if remoteConfigPtr != nil {
		sb.remoteConfigPtr = remoteConfigPtr
		sb.remoteConfigType = reflect.TypeOf(remoteConfigPtr).String()
	}
	return sb
}
